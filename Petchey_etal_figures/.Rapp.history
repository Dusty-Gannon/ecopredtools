### Start of Owen's code#
## We'll use the code from figure 2 as a basis#
#
## We will make K change through time, starting at K_start,#
## and increasing per time step by K_step#
#
## The Ricker model and a function to iterate it#
ricker  <- function(N, r, K) N*exp(r*(1-N/K)) ## copied from ecolMod package!#
iterate.ricker <- function(r, N, K, its, demo.stoch=F)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  K <- K_start#
  for(i in 2:its) {#
    K <- K + K_step#
    if(K<0) stop("K less than zero")#
    if(!demo.stoch)#
      Ns[i] <- ricker(Ns[i-1], r, K)#
    if(demo.stoch) {#
      exp.N <- ricker(Ns[i-1], r, K)#
      Ns[i] <- exp.N + rnorm(1, exp.N, sd=exp.N*0.01)#
    }#
  }#
  Ns#
} #
#
## Set the parameters of the numerical "experiment"#
#
## Distribution from which to choose "real" value of K_step#
K_step.real.mean <- c(0,2)#
K_step.real.sd <- 0#
#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
## uncertainty in r for prediction#
r.pred.sd <-  0  #c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 0.001, 0.02)#
## uncertainty in K_step for prediction#
K_step.pred.sd <-  c(0, 0.001, 0.02)#
#
## switch for demographic stochasticity#
demo.stoch <- c(F)#
#
## replicate predicted time series#
reps <- 1:10#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    K_step.real.mean=K_step.real.mean,#
                    K_step.real.sd=K_step.real.sd,                    #
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    K_step.pred.sd=K_step.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r, N0, and K_step (can be a bit redundant when real.???.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
expt$K_step.real <- rnorm(length(expt[,1]), mean=expt$K_step.real.mean, sd=expt$K_step.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
expt$K_step.pred <- rnorm(length(expt[,1]), mean=expt$K_step.real, sd=expt$K_step.pred.sd)#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)
expt
its <- 50
K_start <- 100
## The Ricker model and a function to iterate it#
ricker  <- function(N, r, K)#
	N*exp(r*(1-N/K)) ## copied from ecolMod package!#
iterate.ricker <- function(r, N, K_step, its, demo.stoch=F)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  K <- K_start#
  for(i in 2:its) {#
    K <- K + K_step#
    if(K<0) stop("K less than zero")#
    if(!demo.stoch)#
      Ns[i] <- ricker(Ns[i-1], r, K)#
    if(demo.stoch) {#
      exp.N <- ricker(Ns[i-1], r, K)#
      Ns[i] <- exp.N + rnorm(1, exp.N, sd=exp.N*0.01)#
    }#
  }#
  Ns#
} #
#
## Set the parameters of the numerical "experiment"#
#
## Distribution from which to choose "real" value of K_step#
K_step.real.mean <- c(0,2)#
K_step.real.sd <- 0#
#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
## uncertainty in r for prediction#
r.pred.sd <-  0  #c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 0.001, 0.02)#
## uncertainty in K_step for prediction#
K_step.pred.sd <-  c(0, 0.001, 0.02)#
#
## switch for demographic stochasticity#
demo.stoch <- c(F)#
#
## replicate predicted time series#
reps <- 1:10#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    K_step.real.mean=K_step.real.mean,#
                    K_step.real.sd=K_step.real.sd,                    #
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    K_step.pred.sd=K_step.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r, N0, and K_step (can be a bit redundant when real.???.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
expt$K_step.real <- rnorm(length(expt[,1]), mean=expt$K_step.real.mean, sd=expt$K_step.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
expt$K_step.pred <- rnorm(length(expt[,1]), mean=expt$K_step.real, sd=expt$K_step.pred.sd)#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
#
## Choose how long to run the simulations for#
its <- 50#
K_start <- 100
real.dyn <- lapply(1:length(expt[,1]),
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              K_step=expt[x, "N0.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))
real.dyn
expt
real.dyn <- lapply(1:length(expt[,1]),
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              K_step=expt[x, "K_step.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))
## Make the predicted dynanimcs
## Make the predicted dynanimcs#
pred.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.pred"],#
                                              N=expt[x, "N0.pred"],#
                                              K_step=expt[x, "K_step.pred"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))
pred.dyn
## Distribution from which to choose "real" value of K_step#
K_step.real.mean <- c(0,10)#
K_step.real.sd <- 0#
#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
## uncertainty in r for prediction#
r.pred.sd <-  0  #c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 0.001, 0.02)#
## uncertainty in K_step for prediction#
K_step.pred.sd <-  c(0, 0.001, 0.02)#
#
## switch for demographic stochasticity#
demo.stoch <- c(F)#
#
## replicate predicted time series#
reps <- 1:10#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    K_step.real.mean=K_step.real.mean,#
                    K_step.real.sd=K_step.real.sd,                    #
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    K_step.pred.sd=K_step.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r, N0, and K_step (can be a bit redundant when real.???.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
expt$K_step.real <- rnorm(length(expt[,1]), mean=expt$K_step.real.mean, sd=expt$K_step.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
expt$K_step.pred <- rnorm(length(expt[,1]), mean=expt$K_step.real, sd=expt$K_step.pred.sd)#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
#
## Choose how long to run the simulations for#
its <- 50#
K_start <- 100#
#
## Make the real dynanimcs#
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              K_step=expt[x, "K_step.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#
## Make the predicted dynanimcs#
pred.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.pred"],#
                                              N=expt[x, "N0.pred"],#
                                              K_step=expt[x, "K_step.pred"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))
real.dyn
plot(read.dyn[[1]])
plot(real.dyn[[1]])
plot(real.dyn[[1]], type="l")
head(expt)
plot(real.dyn[[2]], type="l")
par(mfrow=c(2,1))
plot(real.dyn[[1]], type="l")
plot(real.dyn[[2]], type="l")
par(mfrow=c(2,1))
plot(pred.dyn[[1]], type="l")
plot(pred.dyn[[2]], type="l")
## Some ugly code that will let us merge the expt info with the prediction skills
expt.long  <- expt[rep(row.names(expt), each=its-ma.width+1),]
ma.width <- 3
expt.long  <- expt[rep(row.names(expt), each=its-ma.width+1),]
expt.long$its <- rep(1:(its-ma.width+1), length(expt.long[,1])/(its-ma.width+1))
mov.cor <- lapply(1:length(expt[,1]),
function(xx) rollapply(cbind(real.dyn[[xx]], pred.dyn[[xx]]),
width=ma.width, function(x) cor(x)[1,2], by.column=F))
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(100)
mov.cor <- lapply(1:length(expt[,1]),#
                  function(xx) rollapply(cbind(real.dyn[[xx]], pred.dyn[[xx]]),#
                                         width=ma.width, function(x) cor(x)[1,2], by.column=F))
## Some housekeeping#
mov.cor <- stack(as.data.frame(mov.cor))[,1]#
rr <- data.frame(expt.long, mov.cor)
emp.CL <- function(x, percent) sort(x)[percent/100*length(x)]
pred.skill.threshold <- 0.5
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, demo.stoch, its) %>%#
  summarise(median.pred.skill=median(mov.cor),#
            mean.pred.skill=mean(mov.cor),#
            upper.CL=emp.CL(mov.cor, 55),#
            lower.CL=emp.CL(mov.cor, 45))
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(rownames(rr2), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2
expt
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)
g
rr1$K_step.pred.sd
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch, its) %>%
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch, its) %>%#
  summarise(median.pred.skill=median(mov.cor),#
            mean.pred.skill=mean(mov.cor),#
            upper.CL=emp.CL(mov.cor, 55),#
            lower.CL=emp.CL(mov.cor, 45))
## Get the prediction horizon for the averaged prediction skill#
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(rownames(rr2), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)
g
## Distribution from which to choose "real" value of K_step#
K_step.real.mean <- c(10)#
K_step.real.sd <- 0#
#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
## uncertainty in r for prediction#
r.pred.sd <-  0  #c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 0.001, 0.02)#
## uncertainty in K_step for prediction#
K_step.pred.sd <-  c(0, 0.001, 0.02)#
#
## switch for demographic stochasticity#
demo.stoch <- c(F)#
#
## replicate predicted time series#
reps <- 1:10#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    K_step.real.mean=K_step.real.mean,#
                    K_step.real.sd=K_step.real.sd,                    #
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    K_step.pred.sd=K_step.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r, N0, and K_step (can be a bit redundant when real.???.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
expt$K_step.real <- rnorm(length(expt[,1]), mean=expt$K_step.real.mean, sd=expt$K_step.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
expt$K_step.pred <- rnorm(length(expt[,1]), mean=expt$K_step.real, sd=expt$K_step.pred.sd)#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
#
## Choose how long to run the simulations for#
its <- 50#
K_start <- 100#
#
## Make the real dynanimcs#
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              K_step=expt[x, "K_step.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
par(mfrow=c(2,1))                                     #
plot(real.dyn[[1]], type="l")#
plot(real.dyn[[2]], type="l")#
#
## Make the predicted dynanimcs#
pred.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.pred"],#
                                              N=expt[x, "N0.pred"],#
                                              K_step=expt[x, "K_step.pred"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
par(mfrow=c(2,1))                                     #
plot(pred.dyn[[1]], type="l")#
plot(pred.dyn[[2]], type="l")#
#
## Choose the width of the moving window for calculating prediction skill#
ma.width <- 3#
#
## Some ugly code that will let us merge the expt info with the prediction skills#
expt.long  <- expt[rep(row.names(expt), each=its-ma.width+1),]#
expt.long$its <- rep(1:(its-ma.width+1), length(expt.long[,1])/(its-ma.width+1))#
#
## Calculate the prediction skills#
## Here it is the correlation between the real and predicted abundances in the window#
mov.cor <- lapply(1:length(expt[,1]),#
                  function(xx) rollapply(cbind(real.dyn[[xx]], pred.dyn[[xx]]),#
                                         width=ma.width, function(x) cor(x)[1,2], by.column=F))#
#
## Some housekeeping#
mov.cor <- stack(as.data.frame(mov.cor))[,1]#
rr <- data.frame(expt.long, mov.cor)#
#
## A function to get empirical confidence limits#
emp.CL <- function(x, percent) sort(x)[percent/100*length(x)]#
#
## Set the prediction skill threshold... used to get the prediction horizon#
pred.skill.threshold <- 0.5																#
#
## get the average etc of the prediction skills across the replicates#
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch, its) %>%#
  summarise(median.pred.skill=median(mov.cor),#
            mean.pred.skill=mean(mov.cor),#
            upper.CL=emp.CL(mov.cor, 55),#
            lower.CL=emp.CL(mov.cor, 45))#
#
## Get the prediction horizon for the averaged prediction skill#
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(rownames(rr2), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
#
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
  g
### Start of Owen's code#
## We'll use the code from figure 2 as a basis#
rm(list=ls())#
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(100)#
#
## We will make K change through time, starting at K_start,#
## and increasing per time step by K_step#
#
## The Ricker model and a function to iterate it#
ricker  <- function(N, r, K)#
	N*exp(r*(1-N/K)) ## copied from ecolMod package!#
iterate.ricker <- function(r, N, K_step, its, demo.stoch=F)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  K <- K_start#
  for(i in 2:its) {#
    K <- K + K_step#
    if(K<0) stop("K less than zero")#
    if(!demo.stoch)#
      Ns[i] <- ricker(Ns[i-1], r, K)#
    if(demo.stoch) {#
      exp.N <- ricker(Ns[i-1], r, K)#
      Ns[i] <- exp.N + rnorm(1, exp.N, sd=exp.N*0.01)#
    }#
  }#
  Ns#
} #
#
## Set the parameters of the numerical "experiment"#
#
## Distribution from which to choose "real" value of K_step#
K_step.real.mean <- c(10)#
K_step.real.sd <- 0#
#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
## uncertainty in r for prediction#
r.pred.sd <-  0  #c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 0.001, 0.02)#
## uncertainty in K_step for prediction#
K_step.pred.sd <-  c(0, 0.001, 0.02)#
#
## switch for demographic stochasticity#
demo.stoch <- c(F)#
#
## replicate predicted time series#
reps <- 1:100#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    K_step.real.mean=K_step.real.mean,#
                    K_step.real.sd=K_step.real.sd,                    #
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    K_step.pred.sd=K_step.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r, N0, and K_step (can be a bit redundant when real.???.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
expt$K_step.real <- rnorm(length(expt[,1]), mean=expt$K_step.real.mean, sd=expt$K_step.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
expt$K_step.pred <- rnorm(length(expt[,1]), mean=expt$K_step.real, sd=expt$K_step.pred.sd)#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
#
## Choose how long to run the simulations for#
its <- 50#
K_start <- 100#
#
## Make the real dynanimcs#
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              K_step=expt[x, "K_step.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
par(mfrow=c(2,1))                                     #
plot(real.dyn[[1]], type="l")#
plot(real.dyn[[2]], type="l")#
#
## Make the predicted dynanimcs#
pred.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.pred"],#
                                              N=expt[x, "N0.pred"],#
                                              K_step=expt[x, "K_step.pred"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
par(mfrow=c(2,1))                                     #
plot(pred.dyn[[1]], type="l")#
plot(pred.dyn[[2]], type="l")#
#
## Choose the width of the moving window for calculating prediction skill#
ma.width <- 3#
#
## Some ugly code that will let us merge the expt info with the prediction skills#
expt.long  <- expt[rep(row.names(expt), each=its-ma.width+1),]#
expt.long$its <- rep(1:(its-ma.width+1), length(expt.long[,1])/(its-ma.width+1))#
#
## Calculate the prediction skills#
## Here it is the correlation between the real and predicted abundances in the window#
mov.cor <- lapply(1:length(expt[,1]),#
                  function(xx) rollapply(cbind(real.dyn[[xx]], pred.dyn[[xx]]),#
                                         width=ma.width, function(x) cor(x)[1,2], by.column=F))#
#
## Some housekeeping#
mov.cor <- stack(as.data.frame(mov.cor))[,1]#
rr <- data.frame(expt.long, mov.cor)#
#
## A function to get empirical confidence limits#
emp.CL <- function(x, percent) sort(x)[percent/100*length(x)]#
#
## Set the prediction skill threshold... used to get the prediction horizon#
pred.skill.threshold <- 0.5																#
#
## get the average etc of the prediction skills across the replicates#
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch, its) %>%#
  summarise(median.pred.skill=median(mov.cor),#
            mean.pred.skill=mean(mov.cor),#
            upper.CL=emp.CL(mov.cor, 55),#
            lower.CL=emp.CL(mov.cor, 45))#
#
## Get the prediction horizon for the averaged prediction skill#
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(rownames(rr2), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
#
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
  g
g + geom_line(data=rr3, aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(r.pred.sd)),#
              position="jitter",#
              alpha=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
  g
rr3
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])
rr2
rr3 <- rr2[rep(rownames(rr2), each=2),]
rr3
rep(rownames(rr2)
rownames(rr2)
rep(rownames(rr2), each=2)
rr3 <- rr2[rep(as.numeric(rownames(rr2)), each=2),]
rr3
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2
g + geom_line(data=rr3, aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(r.pred.sd)),#
              position="jitter",#
              alpha=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
g + geom_line(data=rr3, aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              position="jitter",#
              alpha=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
subset(rr3, !is.na(last.pred.skill))
rr3[!is.na(last.pred.skill),]
rr3[!is.na(rr$3last.pred.skill),]
!is.na(rr$3last.pred.skill)
!is.na(rr3$last.pred.skill)
rr3
## Get the prediction horizon for the averaged prediction skill#
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(as.numeric(rownames(rr2)), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2
rr3
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
  g#
g + geom_line(data=rr3[!is.na(rr3$last.pred.skill),],#
	 aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              position="jitter",#
              alpha=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
rr3$pred.horizon!=Inf
rr3[rr3$pred.horizon!=Inf,]
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              position="jitter",#
              alpha=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(r.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(r)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
g + geom_line(data=rr3, aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(r.pred.sd)),#
              position="jitter",#
              alpha=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
quartz(width=3, height=3)
quartz(width=5, height=5)
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
quartz(width=10, height=5)#
g + geom_line(data=rr3, aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(r.pred.sd)),#
              position="jitter",#
              alpha=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
quartz(width=8, height=4)#
g + geom_line(data=rr3, aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(r.pred.sd)),#
              position="jitter",#
              alpha=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
quartz()
### Start of Owen's code#
## We'll use the code from figure 2 as a basis#
rm(list=ls())#
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(100)#
#
## We will make K change through time, starting at K_start,#
## and increasing per time step by K_step#
#
## The Ricker model and a function to iterate it#
ricker  <- function(N, r, K)#
	N*exp(r*(1-N/K)) ## copied from ecolMod package!#
iterate.ricker <- function(r, N, K_step, its, demo.stoch=F)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  K <- K_start#
  for(i in 2:its) {#
    K <- K + K_step#
    if(K<0) stop("K less than zero")#
    if(!demo.stoch)#
      Ns[i] <- ricker(Ns[i-1], r, K)#
    if(demo.stoch) {#
      exp.N <- ricker(Ns[i-1], r, K)#
      Ns[i] <- exp.N + rnorm(1, exp.N, sd=exp.N*0.01)#
    }#
  }#
  Ns#
} #
#
## Set the parameters of the numerical "experiment"#
#
## Distribution from which to choose "real" value of K_step#
K_step.real.mean <- c(10)#
K_step.real.sd <- 0#
#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
## uncertainty in r for prediction#
r.pred.sd <-  0  #c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 0.001, 0.02)#
## uncertainty in K_step for prediction#
K_step.pred.sd <-  c(0, 0.001, 0.02)#
#
## switch for demographic stochasticity#
demo.stoch <- c(F)#
#
## replicate predicted time series#
reps <- 1:50#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    K_step.real.mean=K_step.real.mean,#
                    K_step.real.sd=K_step.real.sd,                    #
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    K_step.pred.sd=K_step.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r, N0, and K_step (can be a bit redundant when real.???.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
expt$K_step.real <- rnorm(length(expt[,1]), mean=expt$K_step.real.mean, sd=expt$K_step.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
expt$K_step.pred <- rnorm(length(expt[,1]), mean=expt$K_step.real, sd=expt$K_step.pred.sd)#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
#
## Choose how long to run the simulations for#
its <- 50#
K_start <- 100#
#
## Make the real dynanimcs#
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              K_step=expt[x, "K_step.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#par(mfrow=c(2,1))                                     #
#plot(real.dyn[[1]], type="l")#
#plot(real.dyn[[2]], type="l")#
#
## Make the predicted dynanimcs#
pred.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.pred"],#
                                              N=expt[x, "N0.pred"],#
                                              K_step=expt[x, "K_step.pred"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#par(mfrow=c(2,1))                                     #
#plot(pred.dyn[[1]], type="l")#
#plot(pred.dyn[[2]], type="l")#
#
## Choose the width of the moving window for calculating prediction skill#
ma.width <- 3#
#
## Some ugly code that will let us merge the expt info with the prediction skills#
expt.long  <- expt[rep(row.names(expt), each=its-ma.width+1),]#
expt.long$its <- rep(1:(its-ma.width+1), length(expt.long[,1])/(its-ma.width+1))#
#
## Calculate the prediction skills#
## Here it is the correlation between the real and predicted abundances in the window#
mov.cor <- lapply(1:length(expt[,1]),#
                  function(xx) rollapply(cbind(real.dyn[[xx]], pred.dyn[[xx]]),#
                                         width=ma.width, function(x) cor(x)[1,2], by.column=F))#
#
## Some housekeeping#
mov.cor <- stack(as.data.frame(mov.cor))[,1]#
rr <- data.frame(expt.long, mov.cor)#
#
## A function to get empirical confidence limits#
emp.CL <- function(x, percent) sort(x)[percent/100*length(x)]#
#
## Set the prediction skill threshold... used to get the prediction horizon#
pred.skill.threshold <- 0.5																#
#
## get the average etc of the prediction skills across the replicates#
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch, its) %>%#
  summarise(median.pred.skill=median(mov.cor),#
            mean.pred.skill=mean(mov.cor),#
            upper.CL=emp.CL(mov.cor, 55),#
            lower.CL=emp.CL(mov.cor, 45))#
#
## Get the prediction horizon for the averaged prediction skill#
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(as.numeric(rownames(rr2)), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2
save.image(file="~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
#
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)
quartz(width=5, height=5)#
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
quartz(width=6, height=5)#
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
quartz(width=5, height=4)#
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
### Start of Owen's code#
## We'll use the code from figure 2 as a basis#
rm(list=ls())#
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(100)#
#
## We will make K change through time, starting at K_start,#
## and increasing per time step by K_step#
#
## The Ricker model and a function to iterate it#
ricker  <- function(N, r, K)#
	N*exp(r*(1-N/K)) ## copied from ecolMod package!#
iterate.ricker <- function(r, N, K_step, its, demo.stoch=F)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  K <- K_start#
  for(i in 2:its) {#
    K <- K + K_step#
    if(K<0) stop("K less than zero")#
    if(!demo.stoch)#
      Ns[i] <- ricker(Ns[i-1], r, K)#
    if(demo.stoch) {#
      exp.N <- ricker(Ns[i-1], r, K)#
      Ns[i] <- exp.N + rnorm(1, exp.N, sd=exp.N*0.01)#
    }#
  }#
  Ns#
} #
#
## Set the parameters of the numerical "experiment"#
#
## Distribution from which to choose "real" value of K_step#
K_step.real.mean <- c(10)#
K_step.real.sd <- 0#
#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
## uncertainty in r for prediction#
r.pred.sd <-  0  #c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 0.001, 0.02)#
## uncertainty in K_step for prediction#
K_step.pred.sd <-  c(0, 0.001, 0.02)#
#
## switch for demographic stochasticity#
demo.stoch <- c(F)#
#
## replicate predicted time series#
reps <- 1:1000#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    K_step.real.mean=K_step.real.mean,#
                    K_step.real.sd=K_step.real.sd,                    #
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    K_step.pred.sd=K_step.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r, N0, and K_step (can be a bit redundant when real.???.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
expt$K_step.real <- rnorm(length(expt[,1]), mean=expt$K_step.real.mean, sd=expt$K_step.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
expt$K_step.pred <- rnorm(length(expt[,1]), mean=expt$K_step.real, sd=expt$K_step.pred.sd)#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
#
## Choose how long to run the simulations for#
its <- 50#
K_start <- 100#
#
## Make the real dynanimcs#
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              K_step=expt[x, "K_step.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#par(mfrow=c(2,1))                                     #
#plot(real.dyn[[1]], type="l")#
#plot(real.dyn[[2]], type="l")#
#
## Make the predicted dynanimcs#
pred.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.pred"],#
                                              N=expt[x, "N0.pred"],#
                                              K_step=expt[x, "K_step.pred"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#par(mfrow=c(2,1))                                     #
#plot(pred.dyn[[1]], type="l")#
#plot(pred.dyn[[2]], type="l")#
#
## Choose the width of the moving window for calculating prediction skill#
ma.width <- 3#
#
## Some ugly code that will let us merge the expt info with the prediction skills#
expt.long  <- expt[rep(row.names(expt), each=its-ma.width+1),]#
expt.long$its <- rep(1:(its-ma.width+1), length(expt.long[,1])/(its-ma.width+1))#
#
## Calculate the prediction skills#
## Here it is the correlation between the real and predicted abundances in the window#
mov.cor <- lapply(1:length(expt[,1]),#
                  function(xx) rollapply(cbind(real.dyn[[xx]], pred.dyn[[xx]]),#
                                         width=ma.width, function(x) cor(x)[1,2], by.column=F))#
#
## Some housekeeping#
mov.cor <- stack(as.data.frame(mov.cor))[,1]#
rr <- data.frame(expt.long, mov.cor)#
#
## A function to get empirical confidence limits#
emp.CL <- function(x, percent) sort(x)[percent/100*length(x)]#
#
## Set the prediction skill threshold... used to get the prediction horizon#
pred.skill.threshold <- 0.5																#
#
## get the average etc of the prediction skills across the replicates#
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch, its) %>%#
  summarise(median.pred.skill=median(mov.cor),#
            mean.pred.skill=mean(mov.cor),#
            upper.CL=emp.CL(mov.cor, 55),#
            lower.CL=emp.CL(mov.cor, 45))#
#
## Get the prediction horizon for the averaged prediction skill#
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(as.numeric(rownames(rr2)), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2#
#
save.image(file="~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
#
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
#
quartz(width=5, height=4)#
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
## Code for figure X1 of Petchey et al#
## This figure and the underlying analysis were suggested by a reviewer, and await full implementation.#
## The reviewer's idea was to include a case study in which there is a directional change in environental#
## conditions. The reviewer gave some R code to illustrate; this code is below.#
## The idea was not included in the revised ms, though not because it is uninteresting / unimportant.#
## Please feel free to further develop the idea.#
## Owen Petchey 27.2.15#
#
### Start of reviewers code#
#### Ricker#
ricker <- function(N, r, temp)#
  {#
  K <- K_mean + 40*temp#
  N_t <- N*exp(r*(1-(N/K)))#
  return(N_t)#
}#
#
N1 <- 100#
r <- 2.05#
K_mean <- 100#
tlimit <- 500#
N <- numeric(tlimit)#
N[1] <- N1#
temp <- c(rnorm(tlimit/2, 12, 1), rnorm(tlimit/2, 18, 1))#
for(t in 2:tlimit){#
  N[t] <- ricker(N[t-1], r, temp[t])#
}#
par(mfrow=c(2,1))#
plot(c(1:tlimit), N, type="l", xlab="time")#
abline(v = 250, col="dodgerblue", lwd=4)#
plot(c(1:tlimit), temp, type="l", xlab="time", ylab="environmental driver")#
abline(v = 250, col="dodgerblue", lwd=4)#
### End of reviewers code#
### Start of Owen's code#
## We'll use the code from figure 2 as a basis#
rm(list=ls())#
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(100)#
#
## We will make K change through time, starting at K_start,#
## and increasing per time step by K_step#
#
## The Ricker model and a function to iterate it#
ricker  <- function(N, r, K)#
	N*exp(r*(1-N/K)) ## copied from ecolMod package!#
iterate.ricker <- function(r, N, K_step, its, demo.stoch=F)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  K <- K_start#
  for(i in 2:its) {#
    K <- K + K_step#
    if(K<0) stop("K less than zero")#
    if(!demo.stoch)#
      Ns[i] <- ricker(Ns[i-1], r, K)#
    if(demo.stoch) {#
      exp.N <- ricker(Ns[i-1], r, K)#
      Ns[i] <- exp.N + rnorm(1, exp.N, sd=exp.N*0.01)#
    }#
  }#
  Ns#
} #
#
## Set the parameters of the numerical "experiment"#
#
## Distribution from which to choose "real" value of K_step#
K_step.real.mean <- c(10)#
K_step.real.sd <- 0#
#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
## uncertainty in r for prediction#
r.pred.sd <-  0  #c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 0.001, 0.02)#
## uncertainty in K_step for prediction#
K_step.pred.sd <-  c(0, 0.1, 2)#
#
## switch for demographic stochasticity#
demo.stoch <- c(F)#
#
## replicate predicted time series#
reps <- 1:1000#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    K_step.real.mean=K_step.real.mean,#
                    K_step.real.sd=K_step.real.sd,                    #
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    K_step.pred.sd=K_step.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r, N0, and K_step (can be a bit redundant when real.???.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
expt$K_step.real <- rnorm(length(expt[,1]), mean=expt$K_step.real.mean, sd=expt$K_step.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
expt$K_step.pred <- rnorm(length(expt[,1]), mean=expt$K_step.real, sd=expt$K_step.pred.sd)#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
#
## Choose how long to run the simulations for#
its <- 50#
K_start <- 100#
#
## Make the real dynanimcs#
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              K_step=expt[x, "K_step.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#par(mfrow=c(2,1))                                     #
#plot(real.dyn[[1]], type="l")#
#plot(real.dyn[[2]], type="l")#
#
## Make the predicted dynanimcs#
pred.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.pred"],#
                                              N=expt[x, "N0.pred"],#
                                              K_step=expt[x, "K_step.pred"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#par(mfrow=c(2,1))                                     #
#plot(pred.dyn[[1]], type="l")#
#plot(pred.dyn[[2]], type="l")#
#
## Choose the width of the moving window for calculating prediction skill#
ma.width <- 3#
#
## Some ugly code that will let us merge the expt info with the prediction skills#
expt.long  <- expt[rep(row.names(expt), each=its-ma.width+1),]#
expt.long$its <- rep(1:(its-ma.width+1), length(expt.long[,1])/(its-ma.width+1))#
#
## Calculate the prediction skills#
## Here it is the correlation between the real and predicted abundances in the window#
mov.cor <- lapply(1:length(expt[,1]),#
                  function(xx) rollapply(cbind(real.dyn[[xx]], pred.dyn[[xx]]),#
                                         width=ma.width, function(x) cor(x)[1,2], by.column=F))#
#
## Some housekeeping#
mov.cor <- stack(as.data.frame(mov.cor))[,1]#
rr <- data.frame(expt.long, mov.cor)#
#
## A function to get empirical confidence limits#
emp.CL <- function(x, percent) sort(x)[percent/100*length(x)]#
#
## Set the prediction skill threshold... used to get the prediction horizon#
pred.skill.threshold <- 0.5																#
#
## get the average etc of the prediction skills across the replicates#
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch, its) %>%#
  summarise(median.pred.skill=median(mov.cor),#
            mean.pred.skill=mean(mov.cor),#
            upper.CL=emp.CL(mov.cor, 55),#
            lower.CL=emp.CL(mov.cor, 45))#
#
## Get the prediction horizon for the averaged prediction skill#
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(as.numeric(rownames(rr2)), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2#
#
save.image(file="~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
## Only run from here once you have a dataset saved#
#
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
#
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
#
quartz(width=5, height=4)#
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
## Code for figure X1 of Petchey et al#
## This figure and the underlying analysis were suggested by a reviewer, and await full implementation.#
## The reviewer's idea was to include a case study in which there is a directional change in environental#
## conditions. The reviewer gave some R code to illustrate; this code is below.#
## The idea was not included in the revised ms, though not because it is uninteresting / unimportant.#
## Please feel free to further develop the idea.#
## Owen Petchey 27.2.15#
#
### Start of reviewers code#
#### Ricker#
ricker <- function(N, r, temp)#
  {#
  K <- K_mean + 40*temp#
  N_t <- N*exp(r*(1-(N/K)))#
  return(N_t)#
}#
#
N1 <- 100#
r <- 2.05#
K_mean <- 100#
tlimit <- 500#
N <- numeric(tlimit)#
N[1] <- N1#
temp <- c(rnorm(tlimit/2, 12, 1), rnorm(tlimit/2, 18, 1))#
for(t in 2:tlimit){#
  N[t] <- ricker(N[t-1], r, temp[t])#
}#
par(mfrow=c(2,1))#
plot(c(1:tlimit), N, type="l", xlab="time")#
abline(v = 250, col="dodgerblue", lwd=4)#
plot(c(1:tlimit), temp, type="l", xlab="time", ylab="environmental driver")#
abline(v = 250, col="dodgerblue", lwd=4)#
### End of reviewers code#
### Start of Owen's code#
## We'll use the code from figure 2 as a basis#
rm(list=ls())#
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(100)#
#
## We will make K change through time, starting at K_start,#
## and increasing per time step by K_step#
#
## The Ricker model and a function to iterate it#
ricker  <- function(N, r, K)#
	N*exp(r*(1-N/K)) ## copied from ecolMod package!#
iterate.ricker <- function(r, N, K_step, its, demo.stoch=F)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  K <- K_start#
  for(i in 2:its) {#
    K <- K + K_step#
    if(K<0) stop("K less than zero")#
    if(!demo.stoch)#
      Ns[i] <- ricker(Ns[i-1], r, K)#
    if(demo.stoch) {#
      exp.N <- ricker(Ns[i-1], r, K)#
      Ns[i] <- exp.N + rnorm(1, exp.N, sd=exp.N*0.01)#
    }#
  }#
  Ns#
} #
#
## Set the parameters of the numerical "experiment"#
#
## Distribution from which to choose "real" value of K_step#
K_step.real.mean <- c(10)#
K_step.real.sd <- 0#
#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
## uncertainty in r for prediction#
r.pred.sd <-  0  #c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 0.001, 0.02)#
## uncertainty in K_step for prediction#
K_step.pred.sd <-  c(0, 0.01, 0.2)#
#
## switch for demographic stochasticity#
demo.stoch <- c(F)#
#
## replicate predicted time series#
reps <- 1:1000#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    K_step.real.mean=K_step.real.mean,#
                    K_step.real.sd=K_step.real.sd,                    #
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    K_step.pred.sd=K_step.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r, N0, and K_step (can be a bit redundant when real.???.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
expt$K_step.real <- rnorm(length(expt[,1]), mean=expt$K_step.real.mean, sd=expt$K_step.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
expt$K_step.pred <- rnorm(length(expt[,1]), mean=expt$K_step.real, sd=expt$K_step.pred.sd)#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
#
## Choose how long to run the simulations for#
its <- 50#
K_start <- 100#
#
## Make the real dynanimcs#
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              K_step=expt[x, "K_step.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#par(mfrow=c(2,1))                                     #
#plot(real.dyn[[1]], type="l")#
#plot(real.dyn[[2]], type="l")#
#
## Make the predicted dynanimcs#
pred.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.pred"],#
                                              N=expt[x, "N0.pred"],#
                                              K_step=expt[x, "K_step.pred"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#par(mfrow=c(2,1))                                     #
#plot(pred.dyn[[1]], type="l")#
#plot(pred.dyn[[2]], type="l")#
#
## Choose the width of the moving window for calculating prediction skill#
ma.width <- 3#
#
## Some ugly code that will let us merge the expt info with the prediction skills#
expt.long  <- expt[rep(row.names(expt), each=its-ma.width+1),]#
expt.long$its <- rep(1:(its-ma.width+1), length(expt.long[,1])/(its-ma.width+1))#
#
## Calculate the prediction skills#
## Here it is the correlation between the real and predicted abundances in the window#
mov.cor <- lapply(1:length(expt[,1]),#
                  function(xx) rollapply(cbind(real.dyn[[xx]], pred.dyn[[xx]]),#
                                         width=ma.width, function(x) cor(x)[1,2], by.column=F))#
#
## Some housekeeping#
mov.cor <- stack(as.data.frame(mov.cor))[,1]#
rr <- data.frame(expt.long, mov.cor)#
#
## A function to get empirical confidence limits#
emp.CL <- function(x, percent) sort(x)[percent/100*length(x)]#
#
## Set the prediction skill threshold... used to get the prediction horizon#
pred.skill.threshold <- 0.5																#
#
## get the average etc of the prediction skills across the replicates#
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch, its) %>%#
  summarise(median.pred.skill=median(mov.cor),#
            mean.pred.skill=mean(mov.cor),#
            upper.CL=emp.CL(mov.cor, 55),#
            lower.CL=emp.CL(mov.cor, 45))#
#
## Get the prediction horizon for the averaged prediction skill#
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(as.numeric(rownames(rr2)), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2#
#
save.image(file="~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
## Only run from here once you have a dataset saved#
#
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
#
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
#
quartz(width=5, height=4)#
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
r.pred.CV <- c(0, 0.0001, 0.002)
r.pred.sd <- r.pred.CV*mean
r.pred.sd <- r.pred.CV*r.real.mean
r.pred.sd
r.pred.CV <- c(0, 0.0004, 0.008)#
r.pred.sd <- r.pred.CV*r.real.mean
r.pred.sd
r.pred.sd <- pred.CV*r.real.mean
pred.CV <- c(0, 0.0005, 0.010)
r.pred.sd <- pred.CV*r.real.mean
r.pred.sd
N0.pred.sd
K_step.pred.sd
K_step.pred.mean
K_step.pred.sd <- pred.CV*K_step.pred.mean
r.pred.sd <- pred.CV*r.real.mean
N0.pred.sd <- pred.CV*N0.real.mean
K_step.pred.sd <- pred.CV*K_step.real.mean
r.pred.sd
N0.pred.sd
K_step.pred.sd
## Code for figure X1 of Petchey et al#
## This figure and the underlying analysis were suggested by a reviewer, and await full implementation.#
## The reviewer's idea was to include a case study in which there is a directional change in environental#
## conditions. The reviewer gave some R code to illustrate; this code is below.#
## The idea was not included in the revised ms, though not because it is uninteresting / unimportant.#
## Please feel free to further develop the idea.#
## Owen Petchey 27.2.15#
#
### Start of reviewers code#
#### Ricker#
ricker <- function(N, r, temp)#
  {#
  K <- K_mean + 40*temp#
  N_t <- N*exp(r*(1-(N/K)))#
  return(N_t)#
}#
#
N1 <- 100#
r <- 2.05#
K_mean <- 100#
tlimit <- 500#
N <- numeric(tlimit)#
N[1] <- N1#
temp <- c(rnorm(tlimit/2, 12, 1), rnorm(tlimit/2, 18, 1))#
for(t in 2:tlimit){#
  N[t] <- ricker(N[t-1], r, temp[t])#
}#
par(mfrow=c(2,1))#
plot(c(1:tlimit), N, type="l", xlab="time")#
abline(v = 250, col="dodgerblue", lwd=4)#
plot(c(1:tlimit), temp, type="l", xlab="time", ylab="environmental driver")#
abline(v = 250, col="dodgerblue", lwd=4)#
### End of reviewers code#
### Start of Owen's code#
## We'll use the code from figure 2 as a basis#
rm(list=ls())#
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(100)#
#
## We will make K change through time, starting at K_start,#
## and increasing per time step by K_step#
#
## The Ricker model and a function to iterate it#
ricker  <- function(N, r, K)#
	N*exp(r*(1-N/K)) ## copied from ecolMod package!#
iterate.ricker <- function(r, N, K_step, its, demo.stoch=F)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  K <- K_start#
  for(i in 2:its) {#
    K <- K + K_step#
    if(K<0) stop("K less than zero")#
    if(!demo.stoch)#
      Ns[i] <- ricker(Ns[i-1], r, K)#
    if(demo.stoch) {#
      exp.N <- ricker(Ns[i-1], r, K)#
      Ns[i] <- exp.N + rnorm(1, exp.N, sd=exp.N*0.01)#
    }#
  }#
  Ns#
} #
#
## Set the parameters of the numerical "experiment"#
#
## Distribution from which to choose "real" value of K_step#
K_step.real.mean <- c(10)#
K_step.real.sd <- 0#
#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
## uncertainty in r for prediction#
#r.pred.sd <-  0  #c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
#N0.pred.sd <-  c(0, 0.001, 0.02)#
## uncertainty in K_step for prediction#
#K_step.pred.sd <-  c(0, 0.01, 0.2)#
## use standard deviation instead of sd#
pred.CV <- c(0, 0.0005, 0.010)#
r.pred.sd <- pred.CV*r.real.mean#
N0.pred.sd <- pred.CV*N0.real.mean#
K_step.pred.sd <- pred.CV*K_step.real.mean#
## switch for demographic stochasticity#
demo.stoch <- c(F)#
#
## replicate predicted time series#
reps <- 1:1000#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    K_step.real.mean=K_step.real.mean,#
                    K_step.real.sd=K_step.real.sd,                    #
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    K_step.pred.sd=K_step.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r, N0, and K_step (can be a bit redundant when real.???.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
expt$K_step.real <- rnorm(length(expt[,1]), mean=expt$K_step.real.mean, sd=expt$K_step.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
expt$K_step.pred <- rnorm(length(expt[,1]), mean=expt$K_step.real, sd=expt$K_step.pred.sd)#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
#
## Choose how long to run the simulations for#
its <- 50#
K_start <- 100#
#
## Make the real dynanimcs#
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              K_step=expt[x, "K_step.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#par(mfrow=c(2,1))                                     #
#plot(real.dyn[[1]], type="l")#
#plot(real.dyn[[2]], type="l")#
#
## Make the predicted dynanimcs#
pred.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.pred"],#
                                              N=expt[x, "N0.pred"],#
                                              K_step=expt[x, "K_step.pred"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#par(mfrow=c(2,1))                                     #
#plot(pred.dyn[[1]], type="l")#
#plot(pred.dyn[[2]], type="l")#
#
## Choose the width of the moving window for calculating prediction skill#
ma.width <- 3#
#
## Some ugly code that will let us merge the expt info with the prediction skills#
expt.long  <- expt[rep(row.names(expt), each=its-ma.width+1),]#
expt.long$its <- rep(1:(its-ma.width+1), length(expt.long[,1])/(its-ma.width+1))#
#
## Calculate the prediction skills#
## Here it is the correlation between the real and predicted abundances in the window#
mov.cor <- lapply(1:length(expt[,1]),#
                  function(xx) rollapply(cbind(real.dyn[[xx]], pred.dyn[[xx]]),#
                                         width=ma.width, function(x) cor(x)[1,2], by.column=F))#
#
## Some housekeeping#
mov.cor <- stack(as.data.frame(mov.cor))[,1]#
rr <- data.frame(expt.long, mov.cor)#
#
## A function to get empirical confidence limits#
emp.CL <- function(x, percent) sort(x)[percent/100*length(x)]#
#
## Set the prediction skill threshold... used to get the prediction horizon#
pred.skill.threshold <- 0.5																#
#
## get the average etc of the prediction skills across the replicates#
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch, its) %>%#
  summarise(median.pred.skill=median(mov.cor),#
            mean.pred.skill=mean(mov.cor),#
            upper.CL=emp.CL(mov.cor, 55),#
            lower.CL=emp.CL(mov.cor, 45))#
#
## Get the prediction horizon for the averaged prediction skill#
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, K_step.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(as.numeric(rownames(rr2)), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2#
#
save.image(file="~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
## Only run from here once you have a dataset saved#
#
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
#
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(K_step.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
#
quartz(width=5, height=4)#
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(K_step.pred.sd)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
## Code for figure 2 of Petchey et al#
## Making a graph showing how prediction skill decays into the future#
## Discrete time Ricker model#
## Owen Petchey 16.8.2014#
#
## The prediction skill is calculated by making a "real" time series from a "real" value of r and N0.#
## Then a predicted time series is made, but with a value of r and N0 with some error (uncertainty).#
## Prediction skill is a moving window measure of the match between the real and predicted time series.#
## For each real time series, there are many predicted, so average prediction skill can be calculated.#
## This can all be repeated for specified levels of uncertainty in r and N0 used for prediction.#
## Preliminaries#
rm(list=ls())#
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(100)#
## The Ricker model and a function to iterate it#
ricker  <- function(N,r) N*exp(r*(1-N)) ## copied from ecolMod package!#
iterate.ricker <- function(r, N, its, demo.stoch=F)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  for(i in 2:its) {#
    if(!demo.stoch)#
      Ns[i] <- ricker(Ns[i-1], r)#
    if(demo.stoch) {#
      exp.N <- ricker(Ns[i-1], r)#
      Ns[i] <- exp.N + rnorm(1, exp.N, sd=exp.N*0.01)#
    }#
  }#
  Ns#
} #
## Set the parameters of the numerical "experiment"#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
#
## uncertainty in r for prediction#
#r.pred.sd <- c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
#N0.pred.sd <-  c(0, 0.001, 0.02)#
## use standard deviation instead of sd#
pred.CV <- c(0, 0.0005, 0.010)#
r.pred.sd <- 0   #pred.CV*r.real.mean#
N0.pred.sd <- pred.CV*N0.real.mean#
#K_step.pred.sd <- pred.CV*K_step.real.mean#
## switch for demographic stochasticity#
demo.stoch <- c(F, T)#
#
## replicate predicted time series#
reps <- 1:1000#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r and N0 (this is a bit redundant when real.r.sd and real.N0.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
#
## Choose how long to run the simulations for#
its <- 50#
#
## Make the real dynanimcs#
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#
## Make the real dynanimcs#
pred.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.pred"],#
                                              N=expt[x, "N0.pred"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#
## Choose the width of the moving window for calculating prediction skill#
ma.width <- 3#
#
## Some ugly code that will let us merge the expt info with the prediction skills#
expt.long  <- expt[rep(row.names(expt), each=its-ma.width+1),]#
expt.long$its <- rep(1:(its-ma.width+1), length(expt.long[,1])/(its-ma.width+1))#
#
## Calculate the prediction skills#
## Here it is the correlation between the real and predicted abundances in the window#
mov.cor <- lapply(1:length(expt[,1]),#
                  function(xx) rollapply(cbind(real.dyn[[xx]], pred.dyn[[xx]]),#
                                         width=ma.width, function(x) cor(x)[1,2], by.column=F))#
#
## Some housekeeping#
mov.cor <- stack(as.data.frame(mov.cor))[,1]#
rr <- data.frame(expt.long, mov.cor)#
#
## A function to get empirical confidence limits#
emp.CL <- function(x, percent) sort(x)[percent/100*length(x)]#
#
## Set the prediction skill threshold... used to get the prediction horizon#
pred.skill.threshold <- 0.5																#
#
## get the average etc of the prediction skills across the replicates#
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, demo.stoch, its) %>%#
  summarise(median.pred.skill=median(mov.cor),#
            mean.pred.skill=mean(mov.cor),#
            upper.CL=emp.CL(mov.cor, 55),#
            lower.CL=emp.CL(mov.cor, 45))#
## Get the prediction horizon for the averaged prediction skill#
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(rownames(rr2), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2#
#
save.image(file="~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data1.Rdata")
## Code for figure 2 of Petchey et al#
## Making a graph showing how prediction skill decays into the future#
## Discrete time Ricker model#
## Owen Petchey 16.8.2014#
#
## The prediction skill is calculated by making a "real" time series from a "real" value of r and N0.#
## Then a predicted time series is made, but with a value of r and N0 with some error (uncertainty).#
## Prediction skill is a moving window measure of the match between the real and predicted time series.#
## For each real time series, there are many predicted, so average prediction skill can be calculated.#
## This can all be repeated for specified levels of uncertainty in r and N0 used for prediction.#
## Preliminaries#
rm(list=ls())#
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(100)#
## The Ricker model and a function to iterate it#
ricker  <- function(N,r) N*exp(r*(1-N)) ## copied from ecolMod package!#
iterate.ricker <- function(r, N, its, demo.stoch=F)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  for(i in 2:its) {#
    if(!demo.stoch)#
      Ns[i] <- ricker(Ns[i-1], r)#
    if(demo.stoch) {#
      exp.N <- ricker(Ns[i-1], r)#
      Ns[i] <- exp.N + rnorm(1, exp.N, sd=exp.N*0.01)#
    }#
  }#
  Ns#
} #
## Set the parameters of the numerical "experiment"#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
#
## uncertainty in r for prediction#
#r.pred.sd <- c(0, 0.001, 0.02)#
## uncertainty in N0 for prediction#
#N0.pred.sd <-  c(0, 0.001, 0.02)#
## use standard deviation instead of sd#
pred.CV <- c(0, 0.0005, 0.010)#
r.pred.sd <- pred.CV*r.real.mean#
N0.pred.sd <- pred.CV*N0.real.mean#
#K_step.pred.sd <- pred.CV*K_step.real.mean#
## switch for demographic stochasticity#
demo.stoch <- c(F, T)#
#
## replicate predicted time series#
reps <- 1:1000#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r and N0 (this is a bit redundant when real.r.sd and real.N0.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
#
## Choose how long to run the simulations for#
its <- 50#
#
## Make the real dynanimcs#
real.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.real"],#
                                              N=expt[x, "N0.real"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#
## Make the real dynanimcs#
pred.dyn <- lapply(1:length(expt[,1]),#
                   function(x) iterate.ricker(r=expt[x, "r.pred"],#
                                              N=expt[x, "N0.pred"],#
                                              its=its,#
                                              demo.stoch=expt[x, "demo.stoch"]))#
#
## Choose the width of the moving window for calculating prediction skill#
ma.width <- 3#
#
## Some ugly code that will let us merge the expt info with the prediction skills#
expt.long  <- expt[rep(row.names(expt), each=its-ma.width+1),]#
expt.long$its <- rep(1:(its-ma.width+1), length(expt.long[,1])/(its-ma.width+1))#
#
## Calculate the prediction skills#
## Here it is the correlation between the real and predicted abundances in the window#
mov.cor <- lapply(1:length(expt[,1]),#
                  function(xx) rollapply(cbind(real.dyn[[xx]], pred.dyn[[xx]]),#
                                         width=ma.width, function(x) cor(x)[1,2], by.column=F))#
#
## Some housekeeping#
mov.cor <- stack(as.data.frame(mov.cor))[,1]#
rr <- data.frame(expt.long, mov.cor)#
#
## A function to get empirical confidence limits#
emp.CL <- function(x, percent) sort(x)[percent/100*length(x)]#
#
## Set the prediction skill threshold... used to get the prediction horizon#
pred.skill.threshold <- 0.5																#
#
## get the average etc of the prediction skills across the replicates#
rr1 <- group_by(rr, N0.pred.sd, r.pred.sd, demo.stoch, its) %>%#
  summarise(median.pred.skill=median(mov.cor),#
            mean.pred.skill=mean(mov.cor),#
            upper.CL=emp.CL(mov.cor, 55),#
            lower.CL=emp.CL(mov.cor, 45))#
## Get the prediction horizon for the averaged prediction skill#
rr2 <- group_by(rr1, N0.pred.sd, r.pred.sd, demo.stoch) %>%#
  summarise(pred.horizon=min(its[mean.pred.skill<pred.skill.threshold]-1),#
            last.pred.skill=mean.pred.skill[min(its[mean.pred.skill<pred.skill.threshold]-1)])#
rr3 <- rr2[rep(rownames(rr2), each=2),]#
rr3$last.pred.skill[seq(1,length(rr3$last.pred.skill), 2)] <- -0.2#
#
save.image(file="~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
## Only run from here once you have a dataset saved#
#
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(r.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(r)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
#
quartz(width=8, height=4)#
g + geom_line(data=rr3, aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.sd),#
                            linetype=as.factor(r.pred.sd)),#
              position="jitter",#
              alpha=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05)) #
#
## Plot the distributions of prediction horizons#
# rr4 <- group_by(rr, N0.pred.sd, r.pred.sd, demo.stoch, reps) %>%#
#   summarise(pred.horizon=min(its[mov.cor<pred.skill.threshold]))#
# rr4$nice.r.pred.sd <- paste("sd(r) =", rr4$r.pred.sd)	#
# rr4$nice.ds <- ifelse(rr4$demo.stoch, "With demog. stoch.", "Without demog. stoch.")  #
# ggplot(rr4, aes(x=pred.horizon, fill=as.factor(N0.pred.sd))) +#
#   facet_grid(nice.ds~nice.r.pred.sd) +#
#   geom_density(alpha=0.5, position="identity", adjust=5) +  #
#   labs(x="Prediction horizon", y="Frequency", fill="sd(N0)")
rr3
rr1
rr1[1:100]
rr1[1:100,]
rr2
rr3
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(r.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="sd(N0)", linetype="sd(r)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)
ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(r.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7)
rr1
ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(r.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7)
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")
rr1
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.sd), linetype=as.factor(r.pred.sd))) +#
  geom_line(size=0.7, alpha=0.7)
ggplot(rr1, aex(x=its, y=mean.pred.skill)) +#
geom_line()
ggplot(rr1, aes(x=its, y=mean.pred.skill)) +#
geom_line()
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
#
rr1$N0.pred.CV <- rr1$N0.pred.sd / N0.real.mean#
rr1$K_step.CV <- rr1$K_step.pred.sd / K_step.real.mean#
rr3$N0.pred.CV <- rr3$N0.pred.sd / N0.real.mean#
rr3$K_step.pred.CV <- rr3$K_step.pred.sd / K_step.real.mean
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.CV), linetype=as.factor(r.pred.CV))) +#
  geom_line(size=0.7, alpha=0.7) +#
  # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="CV(N0)", linetype="CV(r)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
#
quartz(width=8, height=4)#
g + geom_line(data=rr3, aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.CV),#
                            linetype=as.factor(r.pred.CV)),#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05)) #
#
## Plot the distributions of prediction horizons#
# rr4 <- group_by(rr, N0.pred.sd, r.pred.sd, demo.stoch, reps) %>%#
#   summarise(pred.horizon=min(its[mov.cor<pred.skill.threshold]))#
# rr4$nice.r.pred.sd <- paste("sd(r) =", rr4$r.pred.sd)	#
# rr4$nice.ds <- ifelse(rr4$demo.stoch, "With demog. stoch.", "Without demog. stoch.")  #
# ggplot(rr4, aes(x=pred.horizon, fill=as.factor(N0.pred.sd))) +#
#   facet_grid(nice.ds~nice.r.pred.sd) +#
#   geom_density(alpha=0.5, position="identity", adjust=5) +  #
#   labs(x="Prediction horizon", y="Frequency", fill="sd(N0)")
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
#
rr1$N0.pred.CV <- rr1$N0.pred.sd / N0.real.mean#
rr1$K_step.CV <- rr1$K_step.pred.sd / K_step.real.mean#
rr3$N0.pred.CV <- rr3$N0.pred.sd / N0.real.mean#
rr3$K_step.pred.CV <- rr3$K_step.pred.sd / K_step.real.mean#
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.CV), linetype=as.factor(K_step.pred.CV))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="CV(N0)", linetype="CV(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
#
quartz(width=5, height=4)#
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.CV),#
                            linetype=as.factor(K_step.pred.CV)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
str(rr3
)
rr3[rr3$pred.horizon!=Inf,]
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
#
rr1$N0.pred.CV <- rr1$N0.pred.sd / N0.real.mean#
rr1$K_step.pred.CV <- rr1$K_step.pred.sd / K_step.real.mean#
rr3$N0.pred.CV <- rr3$N0.pred.sd / N0.real.mean#
rr3$K_step.pred.CV <- rr3$K_step.pred.sd / K_step.real.mean#
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.CV), linetype=as.factor(K_step.pred.CV))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="CV(N0)", linetype="CV(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
#
quartz(width=5, height=4)#
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.CV),#
                            linetype=as.factor(K_step.pred.CV)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
quartz(width=5, height=3.5)
quartz(width=5, height=3.5)#
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.CV),#
                            linetype=as.factor(K_step.pred.CV)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity") #
#
rr1$N0.pred.CV <- rr1$N0.pred.sd / N0.real.mean#
rr1$r.pred.CV <- rr1$r.pred.sd / r.real.mean#
rr3$N0.pred.CV <- rr3$N0.pred.sd / N0.real.mean#
rr3$r.pred.CV <- rr3$r.pred.sd / r.real.mean#
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.CV), linetype=as.factor(r.pred.CV))) +#
  geom_line(size=0.7, alpha=0.7) +#
  # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="CV(N0)", linetype="CV(r)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
#
quartz(width=8, height=3.5)#
g + geom_line(data=rr3, aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.CV),#
                            linetype=as.factor(r.pred.CV)),#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
## Only run from here once you have a dataset saved#
#
rm(list=ls())#
library(ggplot2)#
load("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/data.figX1.Rdata")#
#load("/Users/Frank/Documents/My scientific articles/2015 - Prediction horizons/ecopredtools/Petchey_etal_figures/data/data1.Rdata")#
#
## Plot the loss of prediction skill through time#
rr1$nice.ds <- ifelse(rr1$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
rr3$nice.ds <- ifelse(rr3$demo.stoch, "With demographic stochasticity", "Without demographic stochasticity")  #
#
rr1$N0.pred.CV <- rr1$N0.pred.sd / N0.real.mean#
rr1$K_step.pred.CV <- rr1$K_step.pred.sd / K_step.real.mean#
rr3$N0.pred.CV <- rr3$N0.pred.sd / N0.real.mean#
rr3$K_step.pred.CV <- rr3$K_step.pred.sd / K_step.real.mean#
g <- ggplot(data=rr1, aes(x=its, y=mean.pred.skill, col=as.factor(N0.pred.CV), linetype=as.factor(K_step.pred.CV))) +#
  geom_line(size=0.7, alpha=0.7) + # transparaent colours to better see when lines lay on top of eachother#
  #geom_point(size=1.5, alpha=0.5) + # make graph less busy#
  labs(col="CV(N0)", linetype="CV(K_step)", x="Time (generations)", y="Forecast proficiency") +#
  facet_grid(.~nice.ds) + #
  geom_hline(yintercept=pred.skill.threshold, col="purple", linetype=2, alpha=0.5)#
#
quartz(width=5, height=3.5)#
g + geom_line(data=rr3[rr3$pred.horizon!=Inf,],#
	 						aes(x=pred.horizon,#
                            y=last.pred.skill,#
                            col=as.factor(N0.pred.CV),#
                            linetype=as.factor(K_step.pred.CV)),#
              #position="jitter",#
              alpha=0.7, size=0.7) + # jitter lines#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) + #
  # this addition will display the coordinate system such that the lines indicating the forecast horizon end at the xaxis#
  scale_y_continuous(expand = c(0, 0)) + coord_cartesian(ylim=c(-0.2,1.05))
## Preliminaries#
rm(list=ls())#
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(101)#
## The Ricker model and a function to iterate it#
ricker  <- function(N, r, demo.stoch) {#
  if(!demo.stoch)#
    Nn <- N*exp(r*(1-N))#
  if(demo.stoch) {#
    exp.N <- N*exp(r*(1-N))#
    Nn <- exp.N + rnorm(1, exp.N, sd=exp.N*0.000000)#
  }#
  Nn#
}#
iterate.ricker <- function(r, N, its, demo.stoch)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  for(i in 2:its)#
      Ns[i] <- ricker(Ns[i-1], r, demo.stoch)#
  Ns#
} #
## Set the parameters of the numerical "experiment"#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
#
## uncertainty in r for prediction#
r.pred.sd <- c(0, 10^c(-5,-3,-1))#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 10^c(-5,-3,-1))#
pred.CV <- c(0, 0.0005, 0.010)#
r.pred.sd <- pred.CV*r.real.mean#
N0.pred.sd <- pred.CV*N0.real.mean
r.pred.sd
## Preliminaries#
rm(list=ls())#
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(101)#
## The Ricker model and a function to iterate it#
ricker  <- function(N, r, demo.stoch) {#
  if(!demo.stoch)#
    Nn <- N*exp(r*(1-N))#
  if(demo.stoch) {#
    exp.N <- N*exp(r*(1-N))#
    Nn <- exp.N + rnorm(1, exp.N, sd=exp.N*0.000000)#
  }#
  Nn#
}#
iterate.ricker <- function(r, N, its, demo.stoch)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  for(i in 2:its)#
      Ns[i] <- ricker(Ns[i-1], r, demo.stoch)#
  Ns#
} #
## Set the parameters of the numerical "experiment"#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
#
## uncertainty in r for prediction#
r.pred.sd <- c(0, 10^c(-5,-3,-1))#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 10^c(-5,-3,-1))#
pred.CV <- c(0, 0.0005, 0.010)#
r.pred.sd <- pred.CV*r.real.mean#
N0.pred.sd <- pred.CV*N0.real.mean#
# ## error in r for prediction (fraction)#
#r.pred.sd <- seq(0.001, 0.1, 0.01)#
# ## error in N0 for prediction (fraction)#
#N0.pred.sd <-  seq(0.001, 0.1, 0.01)#
## switch for demographic stochasticity#
demo.stoch <- c(F, T)#
#
## replicate predicted time series#
reps <- 1:10#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r and N0 (this is a bit redundant when real.r.sd and real.N0.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
## Here, the prediction horizon is defined as when the prediction skill measure#
## has been below the prediction skill threshold for a certain number of#
## consecutive times#
#
## set the prediction skill threshold#
pred.skill.threshold <- 0.3#
## set the prediction skill threshold duration#
## i.e., the number of consecutive windows that prediction skill must#
## be below prediction skill threshold#
threshold.duration <- 0.5 ## in number of moving window widths#
## set the maximum duration of simulations#
max.its <- 128#
## set the moving window size for calculating prediction skill#
mov.wind.width <- 20#
#
## run the next line only to test within the get.pred.horizon() function#
##pars <- expt[1,]#
#
## Function to get prediction horizon for each experimental replicate#
get.pred.horizon <- function(pars, pred.skill.threshold, max.its, mov.wind.width, threshold.duration) {#
  ## Some storage#
  N.real <- rep(NA, length=max.its+1)#
  N.sim <- rep(NA, length=max.its+1)#
  N.real[1] <- pars$N0.real#
  N.sim[1] <- pars$N0.pred#
  ma.cor <- rep(NA, length=max.its+1-mov.wind.width+1)#
  ## iterate Ricker just enough for one test of if prediction horizon is met#
  for(i in 2:(mov.wind.width*(threshold.duration+1))) {#
    N.real[i] <- ricker(N.real[i-1], pars$r.real, pars$demo.stoch)#
    N.sim[i] <- ricker(N.sim[i-1], pars$r.pred, F)#
  }#
  ## and get the prediction skills for this initial part of the simulation#
  for(j in 2:(mov.wind.width*threshold.duration+1))#
    ma.cor[j] <- cor(N.real[j:(j+mov.wind.width-1)], N.sim[j:(j+mov.wind.width-1)])#
  ## Now continue doing this until either the prediction horizon or max.its is reached#
  tt=2#
  while(sum(ma.cor[tt:(tt+mov.wind.width*threshold.duration-1)]>pred.skill.threshold)!=0 & i<max.its)#
    {#
    i <- i+1#
    tt <- tt+1#
    j <- j+1#
    N.real[i] <- ricker(N.real[i-1], pars$r.real, pars$demo.stoch)#
    N.sim[i] <- ricker(N.sim[i-1], pars$r.pred, F)#
    ma.cor[j] <- cor(N.real[j:(j+mov.wind.width-1)], N.sim[j:(j+mov.wind.width-1)])#
  }#
  ## Return the prediction horizon#
  tt#
}#
#
## Storage#
expt$pred.horizon <- rep(NA, length(expt[,1]))#
## Run the experiment#
for(i in 1:length(expt[,1]))#
  expt$pred.horizon[i] <- get.pred.horizon(expt[i,], pred.skill.threshold, max.its, mov.wind.width, threshold.duration)
## get average etc prediction horizons by treatments#
CI <- .10#
aa <- group_by(expt, N0.pred.sd, r.pred.sd, demo.stoch) %>%#
  summarise(mean.pred.horizon=mean(pred.horizon),#
            sd.pred.horizon=sd(pred.horizon),#
            median.pred.horizon=median(pred.horizon),#
            upper=smedian.hilow(pred.horizon, conf.int=CI)[3],#
            lower=smedian.hilow(pred.horizon, conf.int=CI)[2])#
#
## amount to dodge by#
pd <- position_dodge(0.3)#
#
## only use the data that isn't NA#
aa$N0.pred.sd#
#
## plot medians#
ggplot(aa[9:32,], aes(x=N0.pred.sd, y=median.pred.horizon,#
                      col=as.factor(r.pred.sd), linetype=as.factor(demo.stoch))) +#
  geom_line(position=pd, alpha=0.75) +#
  geom_point(size=3, position=pd, alpha=0.75) +#
  labs(linetype="Demographic stochasticity",#
       col="Uncertainty in r: sd(r)", x="Uncertainty in N0: sd(N0)", y="Forecast horizon") +#
  ylim(c(0, 40)) +#
  scale_x_continuous(breaks=c(0.1, 0.001, 0.00001), trans="log10", label=comma)+#
  geom_errorbar(aes(ymax=upper, ymin=lower), width=0.8, position=pd) +#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) +#
  geom_point(data=aa[1:8,],size=3, aes(y=jitter(median.pred.horizon)), position=pd)#
#
## not used#
# ggplot(aa, aes(x=log10(N0.pred.sd), y=median.pred.horizon, linetype=demo.stoch)) +#
#   geom_line() +#
#   geom_point() +#
#   labs(linetype="Demographic stochasticity",#
#        col="Uncertainty in r: sd(r)", x="Uncertainty in N0: sd(N0)", y="Prediction horizon") +#
#   ylim(c(0, 40)) +#
#   theme_bw() + theme(legend.key = element_rect(colour = "white")) +#
#   facet_wrap( ~ r.pred.sd)
ggplot(aa[9:32,], aes(x=N0.pred.sd, y=median.pred.horizon,#
                      col=as.factor(r.pred.sd), linetype=as.factor(demo.stoch))) +#
  geom_line(position=pd, alpha=0.75) +#
  geom_point(size=3, position=pd, alpha=0.75) +#
  labs(linetype="Demographic stochasticity",#
       col="Uncertainty in r: sd(r)", x="Uncertainty in N0: sd(N0)", y="Forecast horizon") +#
  ylim(c(0, 40)) +#
  scale_x_continuous(breaks=c(0.1, 0.001, 0.00001), trans="log10")+#
  geom_errorbar(aes(ymax=upper, ymin=lower), width=0.8, position=pd) +#
  theme_bw() + theme(legend.key = element_rect(colour = "white")) +#
  geom_point(data=aa[1:8,],size=3, aes(y=jitter(median.pred.horizon)), position=pd)
aa[9:32,]
## Preliminaries#
rm(list=ls())#
library(zoo)#
library(ggplot2)#
library(Hmisc)#
library(dplyr)#
set.seed(101)#
## The Ricker model and a function to iterate it#
ricker  <- function(N, r, demo.stoch) {#
  if(!demo.stoch)#
    Nn <- N*exp(r*(1-N))#
  if(demo.stoch) {#
    exp.N <- N*exp(r*(1-N))#
    Nn <- exp.N + rnorm(1, exp.N, sd=exp.N*0.000000)#
  }#
  Nn#
}#
iterate.ricker <- function(r, N, its, demo.stoch)#
{#
  Ns <- numeric(length(its)+1)#
  Ns[1] <- N#
  for(i in 2:its)#
      Ns[i] <- ricker(Ns[i-1], r, demo.stoch)#
  Ns#
} #
## Set the parameters of the numerical "experiment"#
## Distribution from which to choose "real" value of r#
r.real.mean <- 2.9 #
r.real.sd <- 0#
#
## Distribution from which to choose "real" value of N0#
N0.real.mean <- 0.8#
N0.real.sd <- 0#
#
## uncertainty in r for prediction#
r.pred.sd <- c(0, 10^c(-5,-3,-1))#
## uncertainty in N0 for prediction#
N0.pred.sd <-  c(0, 10^c(-5,-3,-1))#
pred.CV <- c(0, 0.0005, 0.010)#
r.pred.sd <- pred.CV*r.real.mean#
N0.pred.sd <- pred.CV*N0.real.mean#
# ## error in r for prediction (fraction)#
#r.pred.sd <- seq(0.001, 0.1, 0.01)#
# ## error in N0 for prediction (fraction)#
#N0.pred.sd <-  seq(0.001, 0.1, 0.01)#
## switch for demographic stochasticity#
demo.stoch <- c(F, T)#
#
## replicate predicted time series#
reps <- 1:50#
#
## set up experiment#
expt <- expand.grid(r.real.mean=r.real.mean,#
                    r.real.sd=r.real.sd,#
                    N0.real.mean=N0.real.mean,#
                    N0.real.sd=N0.real.sd,#
                    r.pred.sd=r.pred.sd,#
                    N0.pred.sd=N0.pred.sd,#
                    demo.stoch=demo.stoch,#
                    reps=reps)#
#
## Get the real values of r and N0 (this is a bit redundant when real.r.sd and real.N0.sd = 0)                    #
expt$r.real <- rnorm(length(expt[,1]), mean=expt$r.real.mean, sd=expt$r.real.sd)#
expt$N0.real <- rnorm(length(expt[,1]), mean=expt$N0.real.mean, sd=expt$N0.real.sd)#
#
## Get values of r and N0 to use for predictions#
expt$r.pred <- rnorm(length(expt[,1]), mean=expt$r.real, sd=expt$r.pred.sd)#
expt$N0.pred <- rnorm(length(expt[,1]), mean=expt$N0.real, sd=expt$N0.pred.sd)#
#
## Check the experiment#
str(expt)#
##ggplot(expt, aes(x=N0.pred)) + geom_density()   + facet_grid(N0.pred.sd ~ r.pred.sd)#
## Here, the prediction horizon is defined as when the prediction skill measure#
## has been below the prediction skill threshold for a certain number of#
## consecutive times#
#
## set the prediction skill threshold#
pred.skill.threshold <- 0.3#
## set the prediction skill threshold duration#
## i.e., the number of consecutive windows that prediction skill must#
## be below prediction skill threshold#
threshold.duration <- 0.5 ## in number of moving window widths#
## set the maximum duration of simulations#
max.its <- 128#
## set the moving window size for calculating prediction skill#
mov.wind.width <- 20#
#
## run the next line only to test within the get.pred.horizon() function#
##pars <- expt[1,]
## Function to get prediction horizon for each experimental replicate#
get.pred.horizon <- function(pars, pred.skill.threshold, max.its, mov.wind.width, threshold.duration) {#
  ## Some storage#
  N.real <- rep(NA, length=max.its+1)#
  N.sim <- rep(NA, length=max.its+1)#
  N.real[1] <- pars$N0.real#
  N.sim[1] <- pars$N0.pred#
  ma.cor <- rep(NA, length=max.its+1-mov.wind.width+1)#
  ## iterate Ricker just enough for one test of if prediction horizon is met#
  for(i in 2:(mov.wind.width*(threshold.duration+1))) {#
    N.real[i] <- ricker(N.real[i-1], pars$r.real, pars$demo.stoch)#
    N.sim[i] <- ricker(N.sim[i-1], pars$r.pred, F)#
  }#
  ## and get the prediction skills for this initial part of the simulation#
  for(j in 2:(mov.wind.width*threshold.duration+1))#
    ma.cor[j] <- cor(N.real[j:(j+mov.wind.width-1)], N.sim[j:(j+mov.wind.width-1)])#
  ## Now continue doing this until either the prediction horizon or max.its is reached#
  tt=2#
  while(sum(ma.cor[tt:(tt+mov.wind.width*threshold.duration-1)]>pred.skill.threshold)!=0 & i<max.its)#
    {#
    i <- i+1#
    tt <- tt+1#
    j <- j+1#
    N.real[i] <- ricker(N.real[i-1], pars$r.real, pars$demo.stoch)#
    N.sim[i] <- ricker(N.sim[i-1], pars$r.pred, F)#
    ma.cor[j] <- cor(N.real[j:(j+mov.wind.width-1)], N.sim[j:(j+mov.wind.width-1)])#
  }#
  ## Return the prediction horizon#
  tt#
}#
#
## Storage#
expt$pred.horizon <- rep(NA, length(expt[,1]))#
## Run the experiment#
for(i in 1:length(expt[,1]))#
  expt$pred.horizon[i] <- get.pred.horizon(expt[i,], pred.skill.threshold, max.its, mov.wind.width, threshold.duration)
expt
## get average etc prediction horizons by treatments#
CI <- .10#
aa <- group_by(expt, N0.pred.sd, r.pred.sd, demo.stoch) %>%#
  summarise(mean.pred.horizon=mean(pred.horizon),#
            sd.pred.horizon=sd(pred.horizon),#
            median.pred.horizon=median(pred.horizon),#
            upper=smedian.hilow(pred.horizon, conf.int=CI)[3],#
            lower=smedian.hilow(pred.horizon, conf.int=CI)[2])
aa
view(aa
)
## Code for figure 5 of Petchey et al#
## Graphing the forecasts horizon relationship from Beninca et al 2008#
## with body size and number of trophic link data#
## Owen Petchey 1.12.14#
#
rm(list=ls())#
library(reshape2)#
library(ggplot2)#
library(stringr)#
library(mgcv)#
library(dplyr)#
#
## read in and tidy the data from figure 2 of Beninca et al 2008#
dd <- read.csv("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/fig5.r-squared.csv")#
dd <- melt(dd, id.vars="prediction_time")#
dd <- cbind(dd, do.call(rbind, str_split(dd$variable, "\\.")))#
names(dd) <- c("Prediction.time", "dummy1", "Forecast.proficiency", "Group", "Model")#
str(dd)#
summary(dd)#
## have a look at the data#
ggplot(dd, aes(x=Prediction.time, y=Forecast.proficiency, col=Model)) +#
  facet_wrap(~Group) + geom_point() + stat_smooth()#
## we'll fit a polynomial to each data group, and use this sp to get the forecast horizon#
dd.s <- split(dd, list(dd$Model, dd$Group))#
rez <- list()#
pred <- list()#
p.over <- seq(3.35, 40, 0.1)#
for(i in 1:length(dd.s)) {#
  rez[[i]] <- lm(Forecast.proficiency ~ poly(Prediction.time,4), dd.s[[i]])#
  pred[[i]] <- predict(rez[[i]], newdata=data.frame(Prediction.time=p.over),interval="confidence")#
  pred[[i]]#
}#
pred[[1]]#
rr <- as.data.frame(do.call("rbind", pred))#
rr$Prediction.time <- rep(p.over, length(rr[,1])/length(p.over))#
rr$Model.Group <- rep(names(dd.s), each=length(p.over))#
rr <- cbind(rr, do.call("rbind", str_split(rr$Model.Group, "\\.")))#
names(rr)[6:7] <- c("Model", "Group")#
str(rr)#
#
## Check the polynomial fits#
ggplot(rr, aes(x=Prediction.time, y=fit, col=Model)) +#
  facet_wrap(~Group) + #
  geom_line() +#
  geom_line(aes(y=upr)) + geom_line(aes(y=lwr)) + #
  geom_point(data=dd, aes(y=Forecast.proficiency))#
#
## a function to get the forecast horizon#
get.fh <- function(y, x, threshold)#
  min(x[y<threshold])#
## get the mean, upper, and lower forecast horizons#
mean.fh <- lapply(pred, function(x) get.fh(x[,"fit"], p.over,0.6))      #
lwr.fh <- lapply(pred, function(x) get.fh(x[,"lwr"], p.over,0.6))      #
upr.fh <- lapply(pred, function(x) get.fh(x[,"upr"], p.over,0.6))      #
#
## put the data together#
fh <- data.frame(Model.Group=names(dd.s),#
                 mean=do.call(rbind, mean.fh), #
                 lwr=do.call(rbind, lwr.fh), #
                 upr=do.call(rbind, upr.fh))#
fh <- cbind(fh, do.call("rbind", str_split(fh$Model.Group, "\\.")))#
names(fh)[5:6] <- c("Model", "Group")
ee <- read.csv("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/fig5.groups_real_Heerkloss.csv")[,1:6]
str(ee)
ee$size <- ee$biovol.ug.fresh
ee <- group_by(ee, short, long) %>% summarise(mean.size=mean(size, na.rm=T), mean.link=mean(num.links, na.rm=T))
ee <- read.csv("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/fig5.groups_real_Heerkloss.csv")[,1:7]
str(ee)
ee$size <- ee$biovol.ug.fresh
ee <- group_by(ee, short, long) %>% summarise(mean.size=mean(size, na.rm=T), mean.link=mean(num.links, na.rm=T))
zz <- merge(ee, fh, by.x="short", by.y="Group")
zz.oo <- subset(zz, long!="nitrogen" & long!="phosphorus" & long!="calanoids copepods" & Model=="nonlinear")#
zz.oo$log.mean <- log10(zz.oo$mean.size)
quartz(width=4, height=3.5)
ggplot(zz.oo, aes(x=mean.size, y=mean, col=long)) + theme_bw() +#
  geom_point(size=5) +#
  geom_errorbar(aes(ymax=upr, ymin=lwr), width=0.0) +#
  scale_x_log10() +#
  xlab("Organism size") +#
  ylab("Forecast horizon") +#
  scale_color_discrete(name="Group") + theme(legend.position="none")
zz.oo
ee
## read in the body sizes and the number of trophic links#
ee <- read.csv("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/fig5.groups_real_Heerkloss.csv")[,1:7]#
str(ee)#
#
## get cell volume assuming a sphere#
ee$size <- ee$biovol.ug.fresh#
#
## calculate average size and number of links#
ee <- group_by(ee, short, long) %>% summarise(mean.size=mean(size, na.rm=T), mean.link=mean(num.links, na.rm=T))#
#
## merge the two data sets#
zz <- merge(ee, fh, by.x="short", by.y="Group")#
## if this merge fails, shutdown R, restart it, and try again.#
## select only the relevant variables and model#
zz.oo <- subset(zz, long!="nitrogen" & long!="phosphorus" & long!="calanoids copepods" & Model=="nonlinear")#
zz.oo$log.mean <- log10(zz.oo$mean.size)#
#
## plot the size - forecast horizon relationship#
quartz(width=4, height=3.5)#
ggplot(zz.oo, aes(x=mean.size, y=mean, col=long)) + theme_bw() +#
  geom_point(size=5) +#
  geom_errorbar(aes(ymax=upr, ymin=lwr), width=0.0) +#
  scale_x_log10() +#
  xlab("Organism size") +#
  ylab("Forecast horizon") +#
  scale_color_discrete(name="Group") + theme(legend.position="none")
## plot the number of links - forecast horizon relationship#
quartz(width=5.75, height=3.5)#
ggplot(zz.oo, aes(x=mean.link, y=mean, col=long)) +#
  geom_point(size=5) +#
  geom_errorbar(aes(ymax=upr, ymin=lwr), width=0.0) +#
  xlab("Number of trophic links") +#
  ylab("Forecast horizon") +#
  scale_color_discrete(name="Group")  + theme_bw() + theme(legend.key = element_rect(colour = "white"))
## and check the stats of the relationships#
library(nlme)#
m1 <- lm(mean ~ log.mean + mean.link, zz.oo)#
summary(m1)
m2 <- lm(mean ~ log.mean * mean.link, zz.oo)#
summary(m2)
m3 <- gls(mean ~ log.mean + mean.link, data=zz.oo, weights=varPower(), control=list(maxIter=1000, tolerance=0.01))#
summary(m3)
m4 <- gls(mean ~  log.mean * mean.link, data=zz.oo, weights=varPower(), control=list(maxIter=1000, tolerance=0.01))#
summary(m4)
## Code for figure 5 of Petchey et al#
## Graphing the forecasts horizon relationship from Beninca et al 2008#
## with body size and number of trophic link data#
## Owen Petchey 1.12.14#
#
rm(list=ls())#
library(reshape2)#
library(ggplot2)#
library(stringr)#
library(mgcv)#
library(dplyr)#
#
## read in and tidy the data from figure 2 of Beninca et al 2008#
dd <- read.csv("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/fig5.r-squared.csv")#
dd <- melt(dd, id.vars="prediction_time")#
dd <- cbind(dd, do.call(rbind, str_split(dd$variable, "\\.")))#
names(dd) <- c("Prediction.time", "dummy1", "Forecast.proficiency", "Group", "Model")#
str(dd)#
summary(dd)#
## have a look at the data#
ggplot(dd, aes(x=Prediction.time, y=Forecast.proficiency, col=Model)) +#
  facet_wrap(~Group) + geom_point() + stat_smooth()#
## we'll fit a polynomial to each data group, and use this sp to get the forecast horizon#
dd.s <- split(dd, list(dd$Model, dd$Group))#
rez <- list()#
pred <- list()#
p.over <- seq(3.35, 40, 0.1)#
for(i in 1:length(dd.s)) {#
  rez[[i]] <- lm(Forecast.proficiency ~ poly(Prediction.time,4), dd.s[[i]])#
  pred[[i]] <- predict(rez[[i]], newdata=data.frame(Prediction.time=p.over),interval="confidence")#
  pred[[i]]#
}#
pred[[1]]#
rr <- as.data.frame(do.call("rbind", pred))#
rr$Prediction.time <- rep(p.over, length(rr[,1])/length(p.over))#
rr$Model.Group <- rep(names(dd.s), each=length(p.over))#
rr <- cbind(rr, do.call("rbind", str_split(rr$Model.Group, "\\.")))#
names(rr)[6:7] <- c("Model", "Group")#
str(rr)#
#
## Check the polynomial fits#
ggplot(rr, aes(x=Prediction.time, y=fit, col=Model)) +#
  facet_wrap(~Group) + #
  geom_line() +#
  geom_line(aes(y=upr)) + geom_line(aes(y=lwr)) + #
  geom_point(data=dd, aes(y=Forecast.proficiency))#
#
## a function to get the forecast horizon#
get.fh <- function(y, x, threshold)#
  min(x[y<threshold])#
## get the mean, upper, and lower forecast horizons#
mean.fh <- lapply(pred, function(x) get.fh(x[,"fit"], p.over,0.6))      #
lwr.fh <- lapply(pred, function(x) get.fh(x[,"lwr"], p.over,0.6))      #
upr.fh <- lapply(pred, function(x) get.fh(x[,"upr"], p.over,0.6))      #
#
## put the data together#
fh <- data.frame(Model.Group=names(dd.s),#
                 mean=do.call(rbind, mean.fh), #
                 lwr=do.call(rbind, lwr.fh), #
                 upr=do.call(rbind, upr.fh))#
fh <- cbind(fh, do.call("rbind", str_split(fh$Model.Group, "\\.")))#
names(fh)[5:6] <- c("Model", "Group")#
#
## read in the body sizes and the number of trophic links#
ee <- read.csv("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/fig5.groups_real_Heerkloss.csv")[,1:7]#
str(ee)#
#
## get cell volume assuming a sphere#
ee$size <- ee$biovol.ug.fresh#
#
## calculate average size and number of links#
ee <- group_by(ee, short, long) %>% summarise(mean.size=mean(size, na.rm=T), mean.link=mean(num.links, na.rm=T))#
#
## merge the two data sets#
zz <- merge(ee, fh, by.x="short", by.y="Group")#
## if this merge fails, shutdown R, restart it, and try again.#
## select only the relevant variables and model#
zz.oo <- subset(zz, long!="nitrogen" & long!="phosphorus" & long!="calanoids copepods" & Model=="nonlinear")#
zz.oo$log.mean <- log10(zz.oo$mean.size)#
#
## plot the size - forecast horizon relationship#
quartz(width=4, height=3.5)#
ggplot(zz.oo, aes(x=mean.size, y=mean, col=long)) + theme_bw() +#
  geom_point(size=5) +#
  geom_errorbar(aes(ymax=upr, ymin=lwr), width=0.0) +#
  scale_x_log10() +#
  xlab("Organism size") +#
  ylab("Forecast horizon") +#
  scale_color_discrete(name="Group") + theme(legend.position="none")#
#
## plot the number of links - forecast horizon relationship#
quartz(width=5.75, height=3.5)#
ggplot(zz.oo, aes(x=mean.link, y=mean, col=long)) +#
  geom_point(size=5) +#
  geom_errorbar(aes(ymax=upr, ymin=lwr), width=0.0) +#
  xlab("Number of trophic links") +#
  ylab("Forecast horizon") +#
  scale_color_discrete(name="Group")  + theme_bw() + theme(legend.key = element_rect(colour = "white"))#
## and check the stats of the relationships#
library(nlme)#
m1 <- lm(mean ~ log.mean + mean.link, zz.oo)#
summary(m1)#
#
m2 <- lm(mean ~ log.mean * mean.link, zz.oo)#
summary(m2)#
#
m3 <- gls(mean ~ log.mean + mean.link, data=zz.oo, weights=varPower(), control=list(maxIter=1000, tolerance=0.01))#
summary(m3)#
#
m4 <- gls(mean ~  log.mean * mean.link, data=zz.oo, weights=varPower(), control=list(maxIter=1000, tolerance=0.01))#
summary(m4)
## read in the body sizes and the number of trophic links
ee <- read.csv("~/Dropbox (Dept of Geography)/1. petchey EFH/ecopredtools/Petchey_etal_figures/data/fig5.groups_real_Heerkloss.csv")[,1:7]#
str(ee)#
#
## get cell volume assuming a sphere#
ee$size <- ee$biovol.ug.fresh#
#
## calculate average size and number of links#
ee <- group_by(ee, short, long) %>% summarise(mean.size=10^mean(log10(size), na.rm=T), mean.link=mean(num.links, na.rm=T))
ee
## merge the two data sets#
zz <- merge(ee, fh, by.x="short", by.y="Group")#
## if this merge fails, shutdown R, restart it, and try again.#
## select only the relevant variables and model#
zz.oo <- subset(zz, long!="nitrogen" & long!="phosphorus" & long!="calanoids copepods" & Model=="nonlinear")#
zz.oo$log.mean <- log10(zz.oo$mean.size)#
#
## plot the size - forecast horizon relationship#
quartz(width=4, height=3.5)#
ggplot(zz.oo, aes(x=mean.size, y=mean, col=long)) + theme_bw() +#
  geom_point(size=5) +#
  geom_errorbar(aes(ymax=upr, ymin=lwr), width=0.0) +#
  scale_x_log10() +#
  xlab("Organism size") +#
  ylab("Forecast horizon") +#
  scale_color_discrete(name="Group") + theme(legend.position="none")
## plot the number of links - forecast horizon relationship#
quartz(width=5.75, height=3.5)#
ggplot(zz.oo, aes(x=mean.link, y=mean, col=long)) +#
  geom_point(size=5) +#
  geom_errorbar(aes(ymax=upr, ymin=lwr), width=0.0) +#
  xlab("Number of trophic links") +#
  ylab("Forecast horizon") +#
  scale_color_discrete(name="Group")  + theme_bw() + theme(legend.key = element_rect(colour = "white"))#
## and check the stats of the relationships#
library(nlme)#
m1 <- lm(mean ~ log.mean + mean.link, zz.oo)#
summary(m1)#
#
m2 <- lm(mean ~ log.mean * mean.link, zz.oo)#
summary(m2)#
#
m3 <- gls(mean ~ log.mean + mean.link, data=zz.oo, weights=varPower(), control=list(maxIter=1000, tolerance=0.01))#
summary(m3)#
#
m4 <- gls(mean ~  log.mean * mean.link, data=zz.oo, weights=varPower(), control=list(maxIter=1000, tolerance=0.01))#
summary(m4)
